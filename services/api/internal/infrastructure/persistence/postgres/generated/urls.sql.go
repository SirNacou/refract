// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: urls.sql

package generated

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createURL = `-- name: CreateURL :exec
INSERT INTO urls (
    id,
    short_code,
    original_url,
    domain,
    expires_at,
    has_fixed_expiration,
    is_active,
    metadata
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
)
`

type CreateURLParams struct {
	ID                 int64              `json:"id"`
	ShortCode          string             `json:"short_code"`
	OriginalUrl        string             `json:"original_url"`
	Domain             string             `json:"domain"`
	ExpiresAt          pgtype.Timestamptz `json:"expires_at"`
	HasFixedExpiration bool               `json:"has_fixed_expiration"`
	IsActive           bool               `json:"is_active"`
	Metadata           []byte             `json:"metadata"`
}

func (q *Queries) CreateURL(ctx context.Context, arg CreateURLParams) error {
	_, err := q.db.Exec(ctx, createURL,
		arg.ID,
		arg.ShortCode,
		arg.OriginalUrl,
		arg.Domain,
		arg.ExpiresAt,
		arg.HasFixedExpiration,
		arg.IsActive,
		arg.Metadata,
	)
	return err
}

const existsByShortCode = `-- name: ExistsByShortCode :one
SELECT EXISTS(
    SELECT 1 FROM urls WHERE short_code = $1
)
`

func (q *Queries) ExistsByShortCode(ctx context.Context, shortCode string) (bool, error) {
	row := q.db.QueryRow(ctx, existsByShortCode, shortCode)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const getURLByShortCode = `-- name: GetURLByShortCode :one
SELECT 
    id,
    short_code,
    original_url,
    domain,
    created_at,
    updated_at,
    expires_at,
    has_fixed_expiration,
    click_count,
    is_active,
    metadata
FROM urls
WHERE short_code = $1
LIMIT 1
`

type GetURLByShortCodeRow struct {
	ID                 int64              `json:"id"`
	ShortCode          string             `json:"short_code"`
	OriginalUrl        string             `json:"original_url"`
	Domain             string             `json:"domain"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
	UpdatedAt          pgtype.Timestamptz `json:"updated_at"`
	ExpiresAt          pgtype.Timestamptz `json:"expires_at"`
	HasFixedExpiration bool               `json:"has_fixed_expiration"`
	ClickCount         int64              `json:"click_count"`
	IsActive           bool               `json:"is_active"`
	Metadata           []byte             `json:"metadata"`
}

func (q *Queries) GetURLByShortCode(ctx context.Context, shortCode string) (GetURLByShortCodeRow, error) {
	row := q.db.QueryRow(ctx, getURLByShortCode, shortCode)
	var i GetURLByShortCodeRow
	err := row.Scan(
		&i.ID,
		&i.ShortCode,
		&i.OriginalUrl,
		&i.Domain,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExpiresAt,
		&i.HasFixedExpiration,
		&i.ClickCount,
		&i.IsActive,
		&i.Metadata,
	)
	return i, err
}

const incrementClickCount = `-- name: IncrementClickCount :exec
UPDATE urls
SET click_count = click_count + 1,
    updated_at = CURRENT_TIMESTAMP
WHERE short_code = $1
`

func (q *Queries) IncrementClickCount(ctx context.Context, shortCode string) error {
	_, err := q.db.Exec(ctx, incrementClickCount, shortCode)
	return err
}

const updateExpiration = `-- name: UpdateExpiration :exec
UPDATE urls
SET expires_at = $1,
    updated_at = CURRENT_TIMESTAMP
WHERE short_code = $2
`

type UpdateExpirationParams struct {
	ExpiresAt pgtype.Timestamptz `json:"expires_at"`
	ShortCode string             `json:"short_code"`
}

func (q *Queries) UpdateExpiration(ctx context.Context, arg UpdateExpirationParams) error {
	_, err := q.db.Exec(ctx, updateExpiration, arg.ExpiresAt, arg.ShortCode)
	return err
}
